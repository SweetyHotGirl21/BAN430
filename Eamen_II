library(forecast)
library(ggplot2)
library(ggpubr) #install.packages("ggpuhr")
library(fma)
library(expsmooth)
library(fpp2)
library(seasonal)
library(mFilter) #install.packages("mFilter")
library(tseries) #install.packages("tseries")
library(scales)
library(stargazer) #install.packages("stargazer")

library(urca) #install.packages("urca")

remove(list = ls())

###### Reading Data 
DATA = read.csv(url("https://raw.githubusercontent.com/hendrikdiers/BAN430/master/exam2_2020.csv"), header = TRUE, sep = ";", dec = "," )
DATA = DATA[,1:3]
DATA = na.omit(DATA) #Deleting omitted variables

COM = ts((DATA[,2]), frequency = 4, start = c(1980, 1), end = c(2019,3))
INC = ts((DATA[,3]), frequency = 4, start = c(1980, 1), end = c(2019,3))
h19 = 19

#Training data
COM.train = window(COM, start = 1980, end = c(2014,4))
INC.train = window(INC, start = 1980, end = c(2014,4))

#Test data
COM.test = window(COM, start = (2015))
INC.test = window(INC, start = (2015))

###### Preliminary (exploratory) analysis
summary(COM.train)
summary(INC.test)
quantile(COM.train)
quantile(INC.test)

autoplot(COM.train, series = "Final consumption expenditure")+
  autolayer(INC.train, series = "Net
national disposable income")+
  ggtitle("Plot of both time series (Training Sets)")+
  xlab("Quarter")+
  ylab("Value per Quarter")

ggsubseriesplot(INC.train)+
  ggtitle('Seasonal Series Plot Income (Training Data)')+
  ylab('Net national disposable income')

ggsubseriesplot(COM.train)+
  ggtitle('Seasonal Series Plot Consumption (Training Data)')+
  ylab('Final consumption expenditure')

summary(tslm((COM.train) ~ trend + season))
summary(tslm((INC.train) ~ trend + season))

Acf = ggAcf(COM.train, lag.max = 40)+
  ggtitle("Autocorrelation function for Final consumption expenditure")
#Parctial Autocorrelation plots
Pacf = ggPacf(COM.train, lag.max = 40)+
  ggtitle("Partial Autocorrelation function for Final consumption expenditure")
ggarrange(Acf, Pacf, ncol = 2, nrow=1, legend = NULL,
          font.label = list(size = 14))

Acf = ggAcf(INC.train, lag.max = 40)+
  ggtitle("Autocorrelation function for Net national disposable income")
#Parctial Autocorrelation plots
Pacf = ggPacf(INC.train, lag.max = 40)+
  ggtitle("Partial Autocorrelation function for Net
national disposable income")
ggarrange(Acf, Pacf, ncol = 2, nrow=1, legend = NULL,
          font.label = list(size = 14))

#Test for stationarity
kpss.test(INC.train) #ur.kpss()
kpss.test(COM.train) #summary(ur.kpss(COM.train))

adf.test(INC.train)
adf.test(COM.train)

COM.train.stl = stl(COM.train, t.window = 13, s.window = "periodic", robust = TRUE)
INC.train.stl = stl(INC.train, t.window = 13, s.window = "periodic", robust = TRUE)

autoplot(COM.train.stl) +
  ggtitle("STL decompostion of Final consumption expenditure")

autoplot(INC.train.stl) +
  ggtitle("STL decompostion of Net national disposable income")

COM.train.seasadj.filter = hpfilter(COM.train.stl$time.series[,2], drift=TRUE)
COM.train.seasadj.filter.cycle = ts(COM.train.seasadj.filter$cycle, start = c(1980, 1), end = c(2014, 4), frequency = 4)

COM.train.raw.filter = hpfilter(COM.train, drift=TRUE)
COM.train.raw.filter.cycle = ts(COM.train.raw.filter$cycle, start = c(1980, 1), end = c(2014, 4), frequency = 4)

ggplot()+
  autolayer(COM.train.seasadj.filter.cycle, series = "Seasonal adjusted")+
  autolayer(COM.train.raw.filter.cycle, series = "Seasonal unadjusted")+xlab("Quater")+
  scale_y_continuous(name="Business Cycle")+
  ggtitle(label = "Cycle analysis of Final consumption expenditure")

INC.train.seasadj.filter = hpfilter(INC.train.stl$time.series[,2], drift=TRUE)
INC.train.seasadj.filter.cycle = ts(INC.train.seasadj.filter$cycle, start = c(1980, 1), end = c(2014, 4), frequency = 4)

INC.train.raw.filter = hpfilter(INC.train, drift=TRUE)
INC.train.raw.filter.cycle = ts(INC.train.raw.filter$cycle, start = c(1980, 1), end = c(2014, 4), frequency = 4)

ggplot()+
  autolayer(INC.train.seasadj.filter.cycle, series = "Seasonal adjusted")+
  autolayer(INC.train.raw.filter.cycle, series = "Seasonal unadjusted")+xlab("Quater")+
  scale_y_continuous(name="Business Cycle")+
  ggtitle(label = "Cycle analysis of Net national disposable income")

nsdiffs(COM.train) #indicates that first differencial would make the series stationary 
nsdiffs(INC.train) #indicates that first differencial would make the series stationary

######long run realtionship
qplot(COM.train,INC.train, asp = 1)+
  ylab("Net national disposable income")+xlab("Final consumption expenditure")+
  ggtitle("Scatterplot: Income and Consumption")

###!!! Hier genre noch Input: war das einzige das mir eingefallen ist


#################################
#Forecasting with seasonal ARIMA
#taking seasonal difference lag = 4
COM.train %>% diff(lag=4) %>% ggtsdisplay()
#sereies still seams not to be stationary: applying first diff
COM.train %>% diff(lag=4) %>% diff() %>% ggtsdisplay()
#these plots could be used to identify sufficiant seasonal ARIMA models

#but the auto.arima function take seasonal ARIMA models into account as well
COM.train.arima = auto.arima(COM.train, stepwise = FALSE, approximation = FALSE) #
COM.train.arima #seasonal ARIMA

COM.train.arima.coef = c(COM.train.arima$coef)
COM.train.arima.coef



checkresiduals(COM.train.arima)
#Portmanteau tests for autocorrelation
#Test if errors are coming from a white noise series
#Box Pierce test
Box.test(COM.train.arima$residuals, lag = 10, fitdf = 0)
#Box-Ljung test
Box.test(COM.train.arima$residuals, lag = 10, fitdf = 0, type = "Lj")
#Shapiro_wilk test for residul normality
shapiro.test(COM.train.arima$residuals)

COM.train.arima.fore = forecast(COM.train.arima, h = h19)
autoplot(window(COM.train, start = c(2005,1)), series = "Training Data")+
  autolayer(COM.train.arima.fore, series = "Forecast from ARIMA(2,0,0)(0,1,1)")+
  autolayer(COM.test, series = "Test Data")+
  autolayer(window(COM.train.arima$fitted, start = c(2005,1)), series = "Fitted values from ARIMA(2,0,0)(0,1,1)")+
  ggtitle("Forecasting Consumption with ARIMA(p,d,q)(P,D,Q)4 model")+ scale_y_continuous(name="Final consumption expenditure")+xlab("Quater")

autoplot(COM.train.arima)


###### Forecasting Consumption with Income as explanatory variable
#making both series stationary by taking first log() differential
######################
#!!!!!!!!!Bitte prüfe mal, ob wir mit einer stationären Serie arbeiten müssen 
#Habe die Aufgabe unten mit Level daten bearbeitet
#https://otexts.com/fpp2/forecasting.html
COM.train.diff = diff(log(COM.train), lag = 1)
INC.train.diff = diff(log(INC.train), lag = 1)

kpss.test(COM.train.diff)
kpss.test(INC.train.diff)

summary(ur.df(COM.train.diff, type = "trend", lags = 0))
summary(ur.df(INC.train.diff))

autoplot(cbind(COM.train.diff,INC.train.diff), facets = TRUE)+
  xlab("Quater")+ylab("")+ ggtitle("Quarterly changes in consumption and income")

COM.train.diff.reg = auto.arima(COM.train.diff, xreg = INC.train.diff, stepwise = FALSE, approximation = FALSE)

cbind("Regression Errors" = residuals(COM.train.diff.reg, type="regression"),
      "ARIMA errors" = residuals(COM.train.diff.reg, type="innovation")) %>%
  autoplot(facets=TRUE)

checkresiduals(COM.train.diff.reg)
Box.test(COM.train.diff.reg$residuals, lag = 10, fitdf = 0)
#Box-Ljung test
Box.test(COM.train.diff.reg$residuals, lag = 10, fitdf = 0, type = "Lj")
#Shapiro_wilk test for residul normality
shapiro.test(COM.train.diff.reg$residuals)
######################

######Forecasting level data
COM.train.arima.reg = auto.arima(COM.train, xreg = INC.train, stepwise = FALSE, approximation = FALSE)
COM.train.arima.reg

checkresiduals(COM.train.arima.reg)
Box.test(COM.train.arima.reg$residuals, lag = 10, fitdf = 0)
#Box-Ljung test
Box.test(COM.train.arima.reg$residuals, lag = 10, fitdf = 0, type = "Lj")
#Shapiro_wilk test for residul normality
shapiro.test(COM.train.arima.reg$residuals)

#Forecasting income to use in regression forecast of consumption
INC.train.fore = forecast(INC.train, h = h19)
INC.train.fore.mean = INC.train.fore$mean
summary(INC.train.fore) #ets(M,A,M)

COM.train.arima.reg.fore = forecast(COM.train.arima.reg, xreg = cbind(INC.train = INC.train.fore.mean), h = 19)



autoplot(window(COM.train, start=c(2005,1)), series = "Training Data")+
  autolayer(COM.train.arima.reg.fore, series = "Consumption Foreceat")+
  autolayer(COM.test, series = "Test Data") + xlab("Quater") + ylab("")+
  ggtitle("Forecast from Regression with ARIMA(1,0,0)(2,1,2)[4] errors")



######Using both forecasts 
#average
COM.train.fore.aver = (COM.train.arima.reg.fore$mean+COM.train.arima.fore$mean)/2
autoplot(COM.train.fore.aver, series = "Average forecast")+
  autolayer(window(COM.train, start= c(2005,1)), series = "Training data")+
  autolayer(COM.test, series = "Test data")+
  ylab("")+xlab("Quater")+ggtitle("Forecast with average of both forecasts")

#optimal weights
#regress fitted values on Consumption
COM.train.arima.reg.fit = COM.train.arima.reg$fitted
COM.train.arima.fit = COM.train.arima$fitted

COM.train.reg = auto.arima(COM.train, xreg = cbind(COM.train.arima.reg.fit, COM.train.arima.fit), stepwise = FALSE, approximation = FALSE)
summary(COM.train.reg)

#forecast with with optimal weights
COM.train.reg.fore = forecast(COM.train.reg, xreg = cbind(COM.train.arima.reg.fit = COM.train.arima.reg.fore$mean, COM.train.arima.fit = COM.train.arima.fore$mean), h = 19)
checkresiduals(COM.train.reg.fore)

autoplot(window(COM.train, start= c(2005,1)), series = "Training data")+
  autolayer(COM.train.reg.fore, series = "Optimal weights")+
  autolayer(COM.test, series = "Test data")+
  ylab("")+xlab("Quater")+ggtitle("Forecast with optimal weights")

#Plot of for diffrent forecasts
autoplot(window(COM.train, start = c(2005,1)), series = "Training Data")+
  autolayer(COM.train.reg.fore$mean, series = "Optimal weights")+
  autolayer(COM.train.arima.rec.fore$mean, series = "Income as explanatory variable")+
  autolayer(COM.train.arima.fore$mean, series = "ARIMA")+
  autolayer(COM.train.fore.aver, series = "Average")+
  ylab("")+xlab("Quater")+ggtitle("Plot of four diffrent forecast")

COM.train.reg.fore.acc = accuracy(COM.train.reg.fore, COM.test)
COM.train.arima.reg.fore.acc = accuracy(COM.train.arima.reg.fore, COM.test)
COM.train.arima.fore.acc = accuracy(COM.train.arima.fore, COM.test)
COM.train.fore.aver.acc = accuracy(COM.train.fore.aver, COM.test)

COM.FORE.ACC = as.data.frame(matrix(cbind(COM.train.reg.fore.acc[2,], COM.train.arima.reg.fore.acc[2,], COM.train.arima.fore.acc[,2], COM.train.fore.aver.acc[,2]), 4, 8, byrow = TRUE)
                                   , row.names = c("Optimal weights", "Regression", "ARIMA", "Average"))
colnames(COM.FORE.ACC) = colnames(COM.train.reg.fore.acc)
round(COM.FORE.ACC, digits = 4)
